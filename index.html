<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Cinematic Scroll Reveal with Progress Bar & Blur</title>
<style>
  /* Reset and container setup */
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  html, body {
    width: 100%;
    background: black;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  }

  /* Main cinematic section */
  .cinematic-section {
    position: relative;
    width: 100%;
    height: 300vh; /* Triple height for scroll */
    background: black;
  }

  /* Fixed viewport container */
  .cinematic-viewport {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100vh;
    overflow: hidden;
    z-index: 10;
  }

  /* Image container */
  .image-container {
    position: relative;
    width: 100%;
    height: 100%;
  }

  .image-container img {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center;
    -webkit-user-drag: none;
    user-drag: none;
    -webkit-user-select: none;
    user-select: none;
    pointer-events: none;
  }

  .after-image {
    clip-path: inset(0 0 0 100%);
    transition: none;
  }

  /* Progress bar */
  .progress-bar {
    position: fixed;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%);
    width: 200px;
    height: 2px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 1px;
    z-index: 20;
    opacity: 1; /* Keep visible */
    transition: opacity 0.3s ease;
  }

  .progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #ffe200, #ffb700, #ff8c00);
    border-radius: 1px;
    width: 0%; /* animated via JS */
    transition: width 0.1s ease-out;
    box-shadow: 0 0 8px rgba(255, 226, 0, 0.4);
  }

  /* Progress bar visibility when active (optional) - keep always visible */
  .cinematic-section.active .progress-bar {
    /* No change to opacity; always visible */
  }

  /* Text overlay with blur effect */
  .cinematic-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    color: white;
    z-index: 15;
    font-size: 1.5rem;
    padding: 0 1rem;
    will-change: opacity, transform, filter;
    /* Starting styles */
    opacity: 1;
    filter: blur(0);
  }

  /* Scroll hint styles */
  .scroll-hint {
    position: fixed;
    bottom: 20px;
    right: 30px;
    color: white;
    font-size: 14px;
    opacity: 0.8;
    z-index: 20;
    display: flex;
    align-items: center;
    gap: 10px;
    transition: opacity 0.3s ease;
  }

  .scroll-hint.fade-out {
    opacity: 0;
  }

  .scroll-arrow {
    width: 20px;
    height: 20px;
    border-right: 2px solid white;
    border-bottom: 2px solid white;
    transform: rotate(45deg);
    animation: bounce 2s infinite;
  }

  @keyframes bounce {
    0%, 20%, 50%, 80%, 100% {
      transform: rotate(45deg) translateY(0);
    }
    40% {
      transform: rotate(45deg) translateY(-5px);
    }
    60% {
      transform: rotate(45deg) translateY(-3px);
    }
  }

  /* Loading overlay */
  .loading {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-size: 16px;
    opacity: 0.7;
    z-index: 25;
  }

  /* Responsive adjustments (optional) omitted for brevity */

  @media(max-width: 768px) {
    .cinematic-section { height: 250vh; }
    .progress-bar { width: 150px; bottom: 20px; }
    .scroll-hint { bottom: 15px; right: 20px; font-size: 12px; }
    .cinematic-text { font-size: 1.2rem; }
  }

  @media(max-width: 480px) {
    .cinematic-section { height: 200vh; }
    .cinematic-text { font-size: 1rem; }
  }

  /* Smooth scrolling */
  html { scroll-behavior: smooth; }

  /* Content after cinematic section */
  .content-after {
    background: white;
    min-height: 100vh;
    padding: 4rem 2rem;
    position: relative;
    z-index: 5;
  }

  .content-after h3 {
    font-size: 2rem;
    margin-bottom: 1rem;
    text-align: center;
  }

  .content-after p {
    max-width: 800px;
    margin: 0 auto;
    line-height: 1.6;
    font-size: 1.1rem;
  }
</style>
</head>
<body>

<div class="loading" id="loading">Loading experience...</div>

<section class="cinematic-section" id="cinematic-section">
  <div class="cinematic-viewport" id="cinematic-viewport">
    <div class="image-container">
      <img src="https://media.sellfy.store/images/PXXhbh0L/QKbN/rage_creators_-_solder_feat._dro-capone_official_music_video.00_00_29_21.still015_copy.jpg" alt="Before" id="before-img" />
      <img src="https://media.sellfy.store/images/PXXhbh0L/oKXD/rage_creators_-_solder_feat._dro-capone_official_music_video.00_00_29_21.still014_copy.jpg" class="after-image" alt="After" id="after-img" />
    </div>
    <div class="cinematic-text" id="cinematic-text">
      <p>Scroll to reveal the transformation</p>
    </div>
  </div>

  <div class="progress-bar">
    <div class="progress-fill" id="progress-fill"></div>
  </div>

  <div class="scroll-hint" id="scroll-hint">
    <span>Scroll down</span>
    <div class="scroll-arrow"></div>
  </div>
</section>

<section class="content-after">
  <h3>Continue Your Journey</h3>
  <p>This is where your regular content continues. The cinematic reveal above creates an engaging entry point that naturally leads users into your main content. You can add more sections, products, or information here.</p>
</section>

<script>
(function() {
  'use strict';

  let isLoaded = false;
  let cinematicSection, cinematicViewport, afterImage, progressFill, scrollHint, cinematicText;

  function throttle(func, limit) {
    let inThrottle;
    return function() {
      const args = arguments;
      const context = this;
      if (!inThrottle) {
        func.apply(context, args);
        inThrottle = true;
        setTimeout(() => (inThrottle = false), limit);
      }
    };
  }

  function initializeCinematic() {
    const beforeImg = document.getElementById('before-img');
    const afterImg = document.getElementById('after-img');
    let loadedCount = 0;

    function imageLoaded() {
      loadedCount++;
      if (loadedCount === 2) {
        document.getElementById('loading').style.display = 'none';

        // Get DOM elements
        cinematicSection = document.getElementById('cinematic-section');
        cinematicViewport = document.getElementById('cinematic-viewport');
        afterImage = document.getElementById('after-img');
        progressFill = document.getElementById('progress-fill');
        scrollHint = document.getElementById('scroll-hint');
        cinematicText = document.getElementById('cinematic-text');

        isLoaded = true;
        setupScrollHandler();

        // Hide scroll hint after 5 seconds
        setTimeout(() => {
          if (scrollHint) scrollHint.classList.add('fade-out');
        }, 5000);
      }
    }

    beforeImg.onload = imageLoaded;
    afterImg.onload = imageLoaded;

    if (beforeImg.complete) imageLoaded();
    if (afterImg.complete) imageLoaded();
  }

  function setupScrollHandler() {
    const handleScroll = throttle(() => {
      if (!isLoaded) return;
      const rect = cinematicSection.getBoundingClientRect();
      const windowHeight = window.innerHeight;
      const sectionHeight = cinematicSection.offsetHeight;

      const isInViewport = rect.top < windowHeight && rect.bottom > 0;

      if (isInViewport) {
        const scrollProgress = Math.max(0, Math.min(1, -rect.top / (sectionHeight - windowHeight)));
        const revealPercent = scrollProgress * 100;

        // Image reveal
        afterImage.style.clipPath = `inset(0 0 0 ${100 - revealPercent}%)`;

        // Progress bar
        progressFill.style.width = `${revealPercent}%`;

        // Zoom
        const easedProgress = easeOutCubic(scrollProgress);
        const scale = 1 + easedProgress * 0.05;
        cinematicViewport.style.transform = `scale(${scale})`;

        // Text scale, fade, and blur
        if (cinematicText) {
          if (scrollProgress > 0.2 && scrollProgress < 0.8) {
            const textProgress = (scrollProgress - 0.2) / 0.6;
            const scaleFactor = 1 + textProgress * 0.5; // scale 1 to 1.5
            const opacityFactor = 1 - textProgress; // fade out
            const blurValue = 1 - textProgress; // blur from 0 to 1px

            cinematicText.style.transform = `translate(-50%, -50%) scale(${scaleFactor})`;
            cinematicText.style.opacity = opacityFactor;
            cinematicText.style.filter = `blur(${blurValue}px)`;
          } else if (scrollProgress <= 0.2) {
            // reset to original
            cinematicText.style.transform = `translate(-50%, -50%) scale(1)`;
            cinematicText.style.opacity = 1;
            cinematicText.style.filter = `blur(0)`;
          } else {
            // hidden after 80%
            cinematicText.style.transform = `translate(-50%, -50%) scale(1.5)`;
            cinematicText.style.opacity = 0;
            cinematicText.style.filter = `blur(1px)`;
          }
        }

      } else {
        // Reset when out of view
        if (rect.bottom < 0) {
          afterImage.style.clipPath = `inset(0 0 0 0%)`;
          progressFill.style.width = '100%';
          cinematicViewport.style.transform = 'scale(1)';
          if (cinematicText) {
            cinematicText.style.transform = `translate(-50%, -50%) scale(1)`;
            cinematicText.style.opacity = 1;
            cinematicText.style.filter = `blur(0)`;
          }
        }
        if (rect.top > window.innerHeight) {
          // not reached yet
          afterImage.style.clipPath = `inset(0 0 0 100%)`;
          progressFill.style.width = '0%';
          cinematicViewport.style.transform = 'scale(1)';
          if (cinematicText) {
            cinematicText.style.transform = `translate(-50%, -50%) scale(1)`;
            cinematicText.style.opacity = 1;
            cinematicText.style.filter = `blur(0)`;
          }
        }
      }
    }, 16);

    window.addEventListener('scroll', handleScroll);
    handleScroll(); // initial
  }

  function easeOutCubic(t) {
    return 1 - Math.pow(1 - t, 3);
  }

  function setupMobileInteractions() {
    if ('ontouchstart' in window) {
      let startY = 0;
      let isScrolling = false;
      document.getElementById('cinematic-viewport').addEventListener('touchstart', (e) => {
        startY = e.touches[0].clientY;
        isScrolling = false;
      });
      document.getElementById('cinematic-viewport').addEventListener('touchmove', (e) => {
        if (!isScrolling) {
          const currentY = e.touches[0].clientY;
          const deltaY = startY - currentY;
          if (Math.abs(deltaY) > 10) {
            isScrolling = true;
          }
        }
      });
    }
  }

  function setupVisibilityHandler() {
    if ('IntersectionObserver' in window) {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            document.body.style.willChange = 'scroll-position';
          } else {
            document.body.style.willChange = 'auto';
          }
        });
      });
      observer.observe(cinematicSection || document.body);
    }
  }

  function init() {
    initializeCinematic();
    setupMobileInteractions();
    setupVisibilityHandler();

    // preload images
    const link1 = document.createElement('link');
    link1.rel = 'preload';
    link1.as = 'image';
    link1.href = 'https://media.sellfy.store/images/PXXhbh0L/QKbN/rage_creators_-_solder_feat._dro-capone_official_music_video.00_00_29_21.still015_copy.jpg';

    const link2 = document.createElement('link');
    link2.rel = 'preload';
    link2.as = 'image';
    link2.href = 'https://media.sellfy.store/images/PXXhbh0L/oKXD/rage_creators_-_solder_feat._dro-capone_official_music_video.00_00_29_21.still014_copy.jpg';

    document.head.appendChild(link1);
    document.head.appendChild(link2);
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();
</script>
</body>
</html>